# 02 변수 : 기본 데이터 형식 (Data type)

<br>

## 기본 데이터 형식은 총 15가지
- 숫자 형식(12)   : `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, `double`, `decimal`
- 문자열 형식(1)   : `string`
- 논리 형식(1)    : `bool`
- 오브젝트 형식(1) : `object`

<br>

## 숫자 형식
- **컴퓨터의 목적인 "수를 계산한다" 라는 이유도 있지만, 다른 형태의 복잡한 데이터도 숫자를 기반으로 구성**

<br>
  
- **텍스트 데이터도 각 문자 하나 하나가 내부적으로 숫자 코들로 구성**
  - ex) ASCII 코드상에서 `A`는 65와 같음

<br>

- **숫자 형식의 종류**
  - 정수 계열(9) : `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`
  - 부동 소수 계열(2) : `float`, `double`
  - 소수 계열(1) : `decimal`
 
<br>

## 정수 계열 (Integral Type)

| 데이터 형식   | 설명                       | 크기 (Byte) | 담을 수 있는 값의 범위                     |
|-------------|----------------------------|-------------|--------------------------------------------|
| sbyte       | signed byte (정수)        | 1 (8bit)    | -128 ~ 127                                |
| byte        | 부호 없는 정수            | 1 (8bit)    | 0 ~ 255                                   |
| short       | 정수                       | 2 (16bit)   | -32,768 ~ 32,767                          |
| ushort      | unsigned short (부호 없는 정수) | 2 (16bit)   | 0 ~ 65,535                                |
| int         | 정수                       | 4 (32bit)   | -2,147,483,648 ~ 2,147,483,647            |
| uint        | unsigned int (부호 없는 정수) | 4 (32bit)   | 0 ~ 4,294,967,295                         |
| long        | 정수                       | 8 (64bit)   | -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807 |
| ulong       | unsigned long (부호 없는 정수) | 8 (64bit)   | 0 ~ 18,446,744,073,709,551,615            |
| char        | 유니코드 문자             | 2 (16bit)   | 문자 하나 ex) 'a', '+'                     |


- **무조건 큰 데이터를 사용하면?**
  - 무의하게 버려지는 데이터 공간이 많아질 것
 
<br>

- **작은 데이터를 사용하면?**
    - 한정된 용량보다 더 큰 데이터가 필요할 때 오버플로우(Overflow) 발생
 
<br>

- **바이트(Byte)란?**
  - 1바이트란 8개의 0과 1로 구성되는 데이터 덩어리를 의미
  - 31(10진수) = 0001 1111(2진수)

<br>

## 부호 있는 정수와 부호 없는 정수
- 부호 있는 정수 : `sbyte`, `short`, `int`, `long`
  - "정해진 크기 -1" 만큼의 비트를 수를 표현하는데 사용하고, 나머지 1은 부호를 표현하는데 사용
      - 0 = 0000 0000
      - 1 = 0000 0001
      - 2 = 0000 0010
      - ...
      - 127 = 0111 1111
      - -1 = 1111 1111
 
<br>

- **부호 있는 정수에서 음수의 표현은 2의 보수법(2's Complement) 알고리즘을 사용**
  1. 수 부분 비트를 채운다.
  2. 전체 비트를 반전 시킨다.
  3. 반전된 비트에 1을 더한다.
     - -1의 경우
         1. 0000 0001  // 수 부분 비트를 채움
         2. 1111 1110  // 전체 비트 반전
         3. 1111 1111  // 반전된 비트에 +1

<br>

- 부호 없는 정수 : `byte`, `ushort`, `uint`, `ulong`
   - 정해진 크기 만큼의 비트를 모두 수를 표현하는데 사용
       - 0 = 0000 0000
       - 1 = 0000 0001
       - 2 = 0000 0010
       - ...
       - 255 = 1111 1111
 
 <br>

``` cs
using UnityEngine;

public class Exercise01 : MonoBehaviour
{
    private void Awake()
    {
        sbyte   byteValue    = -128;                        // sbyte: -128 ~ 127 (8-bit 부호 있는 정수)
        byte    ubyteValue   = 255;                         // byte: 0 ~ 255 (8-bit 부호 없는 정수)
        short   shortValue   = -32768;                      // short: -32,768 ~ 32,767 (16-bit 부호 있는 정수)
        ushort  ushortValue  = 65535;                       // ushort: 0 ~ 65,535 (16-bit 부호 없는 정수)
        int     intValue     = -2147483648;                 // int: -2,147,483,648 ~ 2,147,483,647 (32-bit 부호 있는 정수)
        uint    uintValue    = 4294967295;                  // uint: 0 ~ 4,294,967,295 (32-bit 부호 없는 정수)
        long    longValue    = -9223372036854775808;        // long: -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807 (64-bit 부호 있는 정수)
        ulong   ulongValue   = 18446744073709551615;        // ulong: 0 ~ 18,446,744,073,709,551,615 (64-bit 부호 없는 정수)
        char    charValue    = 'K';                         // char: 문자 하나 (예: 'A', '+') (16-bit 유니코드 문자)

        // 디버그 로그 출력
        Debug.Log($"sbyte value: {byteValue}");
        Debug.Log($"byte value: {ubyteValue}");
        Debug.Log($"short value: {shortValue}");
        Debug.Log($"ushort value: {ushortValue}");
        Debug.Log($"int value: {intValue}");
        Debug.Log($"uint value: {uintValue}");
        Debug.Log($"long value: {longValue}");
        Debug.Log($"ulong value: {ulongValue}");
        Debug.Log($"char value: {charValue}");
    }
}
```

<br>

## 부동 소수 계열 (Floating Point Type)과 소수 계열 (Decimal Type)
| 데이터 형식 | 설명                       | 크기 (Byte) | 담을 수 있는 값의 범위                          |
|-------------|----------------------------|-------------|------------------------------------------------|
| float       | 부동소수점 (32-bit 실수)   | 4 (32bit)           | ±1.5 × 10⁻⁴⁵ ~ ±3.4 × 10³⁸                    |
| double      | 부동소수점 (64-bit 실수)   | 8 (64bit)           | ±5.0 × 10⁻³²⁴ ~ ±1.7 × 10³⁰⁸                  |
| decimal     | 고정소수점 (128-bit 실수)  | 16 (128bit)          | ±1.0 × 10⁻²⁸ ~ ±7.9 × 10²⁸ (정확도: 28~29 자릿수) |

<br>

- **부동 소수 계열 (Float Point Type)**
  - "뜰 부, 움직일 동 = 떠서 움직인다" 란 뜻으로 소수점이 고정되어 있지 않고 움직이면서 수를 표현한다는 뜻
  - 부동 소수점 형식은 소수점을 표현하기 위해 일부 비트를 사용
  - 부동 소수점 형식은 산술 연산 과정이 정수 계열 형식보다 복잡해서 느리다.

<br>

- **소수 계열 (Decimal Type)**
  - 실수를 다루는 데이터 형식
  - 부동 소수점과는 다른 방식으로 소수를 다루며 정밀도가 높음

<br>

- `float (Floating Point)`
    - 1비트를 부호 전용, 가수부 23비트를 수를 표현하는데 사용 <br>그리고 나머지 8비트를 소수점의 위치를 나타내기 위해 사용
    - `float`의 범위는  ±1.5 × 10⁻⁴⁵ ~ ±3.4 × 10³⁸
    - 유효숫자는 7밖에 없으니 7자리 이상의 수는 "대략적으로" 표현
        - `float` 형식이 "한정된 정밀도(Precision)"을 가진다는 뜻

<br>

- **32비트 부동소수점 데이터 구조**

  - 총 32비트
    - 부호 비트 (Sign Bit): 1비트
      - 양수(0) 또는 음수(1)를 나타냄  
    - 지수부 (Exponent): 8비트
      - 수의 크기를 조정하기 위해 사용되는 지수 값을 저장 (Bias: 127)
    - 가수부 (Mantissa): 23비트
      - 유효숫자 부분을 저장하며, 정밀도를 결정
     
<br>

- **문자 형식 (Character Type)**
  - 정수 형식이지만 수가 아닌 `'가'`, `'나'`, `'a'`, `'b'`와 같은 문자 데이터를 다룬다.
  - 문자 형식에 데이터를 담는 방법은 작은 따옴표 '와' 로 문자를 감싼다.
    - `char valueChar01 = '객';`
    - `char valueChar02 = '체';`
   
<br>  

- **문자열 형식 (String Type)**
  - 여러 개의 문자(`char`)를 하나로 묶어 표현하는 방법
  - 문자열의 크기는 텍스트의 양에 따라 달라진다.
  - 문자열 형식에 데이터를 담는 방법은 큰 따옴표 `"` 와 `"` 로 문자열을 감싼다
    - `string valueString01 = "참 쉽지?";`
    - `string valueString02 = "이렇게 저장하고 싶은 만큼 저장 가능해";`

<br>

- **논리 형식 (Boolean Type)**
  - 참(`true`)과 거짓(`false`) 데이터를 다루는 형식

<br>

| 데이터 형식 | 설명      | 크기      | 담을 수 있는 값의 범위 |
|-------------|-----------|-----------|-------------------------|
| `bool`      | 논리 형식 | 1 (8비트) | `true`, `false`         |


<br>

  - **`true`, `false`만 표현하는데 8비트를 사용?**
    - `bool` 형식은 참(`true` : 1)과 거짓(`false` : 0)만 표현하기 때문에 1비트만으로 표현이 가능하지만,
    컴퓨터가 다루는 기본 데이터 크기가 바이트 단위이기 때문에 1비트만 저장하려 해도 한 바이트를 통째로 사용

<br>

- **오브젝트 형식 (Object Type)**
  - 어떤 데이터든 다룰 수 있는 형식
  - 실제 데이터는 모르지만 실제 데이터가 저장되어 있는 주소 값은 알고 있음

<br>

- **박싱 (Boxing)**
  - 값 형식의 데이터를 힙에 할당하는 기능
  - `object` 형식에 값 형식의 데이터를 할당하면 `object` 형식은 박싱을 시도해서 해당 데이터를 힙에 할당하고, `object` 형식은 힙의 주소 값을 참조
  - `object value = 31;`

<br>

- **언박싱 (UnBoxing)**
  - 힙에 있는 값 형식 데이터를 값 형식 변수에 할당하는 기능
  - `object` 형식의 데이터를 값 형식의 객체에 할당하면 `object` 형식은 언박싱을 시도해서 힙에 참조하고 있는 데이터를 복사하여 값 형식 객체에 저장
  - `object value = 31;`
  - int valueInt = (int)value;
 
<br>

#### 참고 자료
  - [유튜브 고박사의 유니티 노트 [Unity C#] #02 변수 : 기본 데이터 형식 (Data type)](https://www.youtube.com/watch?v=bA9AVLUSvIo&list=PLC2Tit6NyVicT5cCqILMWXpXVEoM9ufyH&index=2)
