# 06 연산자

## 연산자 개요
변수 데이터를 연산해 다양한 결과를 얻기 위해 사용
결과 값을 대입하는 대입 연산자부터 사칙연산을 하는 산술 연산자 등 제공

|종류|연산자|
|-|-|
|산술 연산자|+, -, *, /, %|
|대입(할당) 연산자|=, +=, -=, *=, /=, %=, <<=, >>=, &=, |=, ^=|
|증감 연산자|++, --|
|비교(관계) 연산자|<. >, ==, !=, <=, >=|
|논리 연산자|&&, ||, !|
|조건(삼항) 연산자|?:|
|비트 연산자|<< ,>> , &, |, ^, ~|

<br>

## 산술 연산자
사칙연산을 수행하는 연산자

|연산자 기호|연산자 명|수행연산|코드 예제|
|+|덧셈 연산자|덧셈 연산을 수행|x + y|
|-|뺄셈 연산자|뺄셈 연산을 수행|x - y|
|*|곱셈 연산자|곱셈 연산을 수행|X * y|
|/|나눗셈 연산자|나눗셈 후 몫을 결과 값으로|x / y|
|%|나머지 연산자|나눗셈 후 나머지 값을 결과 값으로|x % y|

**TIP. 사칙연산은 현실의 산수와 동일 대입 연산의 결과가 오른쪽이 아닌 왼쪽에 위치한다는 것이 다름**

<br>

## 대입(할당) 연산자
결과 값을 대입하는 연산자로 여러 연산을 축약한 대입 연산자도 제공
|연산자 기호|연산자 명|수행연산|코드 예저|
|-|-|-|-|
|=|대입(할당) 연산자|오른쪽의 값을 왼쪽에 대입|`x = 2; y = 5;`|
|+=|덧셈 대입 연산자|`x += y` 는 `x = x + y` 와 같다.|`x += y;`|
|-=|뺄셈 대입 연산자|`x -= y` 는 `x = x - y` 와 같다.|`x -= y;`|
|*=|곱셈 대입 연산자|`x *= y` 는 `x = x * y` 와 같다.|`x *= y;`|
|/=|나눗셈 대입 연산자|`x /= y` 는 `x = x / y` 와 같다.|`x /= y;`|
|%=|나머지 대입 연산자|`x %= y` 는 `x = x % y` 와 같다.|`x %= y;`|
|&=|논리곱 대입 연산자|`x &= y` 는 `x = x & y` 와 같다.|`x &= y;`|
|\|=|논리합 대입 연산자|`x \= y` 는 `x = x \| y` 와 같다.|`x \= y;`|
|^=|배타적 논리합 대입 연산자|`x ^= y` 는 `x = x ^ y` 와 같다.|`x ^= y;`|
|<<=|왼쪽 시프트 대입 연산자|`x <<= y` 는 `x = x << y` 와 같다.|`x <<= y;`|
|>>=|오른쪽 시프트 대입 연산자|`x >>= y` 는 `x = x >> y` 와 같다.|`x >>= y;`|

<br>

## 증감 연산자
수치가 1씩 증가 또는 감소할 때 사용하는 연산자

|연산자 기호|연산자 명|수행연산|코드 예제|
|-|-|-|-|
|`++`|증가 연산자|값을 1 증가시킨다 <br>`x++` 또는 `x++`는 `x = x + 1` 과 같다|`x++`, `++x`|
|`--`|감소 연산자|값을 1 감소시킨다|`x--`, `--x`|`x--`, `--x`|

<br>

연산자가 붙는 위치에 따라 "전위", "후위"로 불리며 연산 순서가 다르다.

|연산자 기호|연산자 명|수행연산|코드 예제|
|-|-|-|-|
|`x++`, `x--`|증가 연산자|값을 1 증가시킨다 <br>`x++` 또는 `x++`는 `x = x + 1` 과 같다|`x++`, `++x`|
|`++x`, `--x`|감소 연산자|값을 1 감소시킨다|`x--`, `--x`|`x--`, `--x`|

<br>

## 비교(관계) 연산자
양쪽의 값을 비교하여 결과를 참(`True`) 또는 거짓(`false`)으로 나타내는 연산자

|연산자 기호|수행연산|코드 예제|결과 값|
|-|-|-|-|
|`>`|왼쪽 값이 오른쪽 값보다 크면 참, <br>아니면 거짓|`bool result; int x = 5; y = 2;` <br>`result = (x > y);`|`true`|
|`<`|왼쪽 값이 오른쪽 값보다 작으면 참, <br>아니면 거짓|`bool result; int x = 5; y = 2;` <br>`result = (x < y);`|`false`|
|`>=`|왼쪽 값이 오른쪽 값보다 크거나 같으면 참, <br>아니면 거짓|`bool result; int x = 5; y = 2;` <br>`result = (x >= y);`|`true`|
|`<=`|왼쪽 값이 오른쪽 값보다 작거나 같으면, 참 <br>아니면 거짓|`bool result; int x = 5; y = 2;` <br>`result = (x <= y);`|`false`|
|`==`|왼쪽 값과 오른쪽 값이 같으면 참, <br>아니면 거짓|`bool result; int x = 5; y = 2;` <br>`result = (x == y);`|`false`|
|`!=`|왼쪽 값과 오른쪽 값이 같지 않으면 참, <br>아니면 거짓|`bool result; int x = 5; y = 2;` <br>`result = (x != y);`|`true`|

<br>

## 논리 연산자
조건을 비교하는 비교 연산자가 동시에 두 개 이상 사용될 때 사용

|연산자 기호|연산자 명|수행연산|코드 예제|결과 값|
|-|-|-|-|-|
|`&&`|AND 연산자|두 개의 조건이 모두 참이면 `true` <br> 그렇지 않을 경우 모두 `false`|`x = 5; y = 2` <br>`result = (x > 2) && (y != 5)`|`true`|
|`\|\|`|OR 연산자|두 개의 조건이 모두 거짓이면 `false` <br> 그렇지 않을 경우 모두 `true`|`result = (x < 4) \|\| (y == 3)`|`false`|
|`!`|NOT 연산자|결과가 참이면 거짓으로 <br>거짓이면 참으로 반전|`bool result = false; <br>result = !result;`|`true`|

<br>

## 조건(삼항) 연산자
조건식을 사용해 조건식의 참, 거짓 여부에 따라 다른 결과 값 대입

|연산자 기호|수행연산|코드 예제|
|-|-|-|
|`?:`|결과 = 조건식 ? (조건식이 참) : (조건식이 거짓); <br>조건식의 참, 거짓에 따라 값을 결과에 대입|`int hp = 100, damage = 200; <br>hp = hp - damage < 0 ? 0 : hp - damage;`|

<br>

``` cs
d = a ? b : c;  // a에는 조건식을 사용해서 true, false 값을 구한다

d = 5 > 2 ? b : c;  // d와 b, c의 변수 타입은 동일해야 한다

int result = 5 > 2 ? 0 : 10;

float result = 5 > 2 ? 0.0f : 10.0f;
```

<br>

## 비트 연산자
비트 단위의 데이터의 연산에 사용
- 시프트 연산의 장점 : 연산 속도가 빠르다.
- 시프트 연산의 단점 : 머리로 계산이 잘 안된다.

|연산자 기호|연산자 명|코드 예제|결과 값|
|-|-|-|-|
|`>>`|오른쪽 시프트 연산자|첫 번째 피연산자의 비트를 두 번째 피연산자의 수만큼 오른쪽으로 이동|첫 번째 피연산자는 `int`, `uint`, `long`, `ulong`이며, 두 번째 피연산자는 `int`형식만 지원|
|`<<`|왼쪽 시프트 연산자|첫 번째 피연산자의 비트를 두 번째 피연산자의 수만큼 왼쪽으로 이동|첫 번째 피연산자는 `int`, `uint`, `long`, `ulong`이며, 두 번째 피연산자는 `int`형식만 지원|
|`&`|논리곱(AND) 연산자|두 피연산자의 비트 논리곱을 수행 (두 비트가 둘 다 1일 때 1 나머지는 0)|`정수 계열 형식과 bool 형식에 대해 사용`|
|`\|\|`|논리합(OR) 연산자|두 피연산자의 비트 논리합을 수행 (두 비트가 둘 다 0 일 때 0 나머지는 1)|`정수 계열 형식과 bool 형식에 대해 사용`|
|`^`|배타적 논리합(XOR) 연산자|두 피연산자의 배타적 논리합을 수행 (두 비트가 같으면 0, 다르면 1)|`정수 계열 형식과 bool 형식에 대해 사용`|
|`~`|보수(NOT) 연산자|피연산자의 비트를 0은 1로, 1은 0으로 반전 (단항 연산자)|`int`, `uint`, `long`, `ulong`에 대해 사용 가능|


<br>

## 시프트 연산
#### 왼쪽 시프트 연산 

<br>

**TIP.** 이해를 돕기 위해 1바이트로 설명하지만 시프트 연산자가 지원하느 형식은 32비트인 `int` 이상

<br>

``` cs
int a =3;
a << 2
```
1. 왼쪽으로 2비트 이동하기 때문에 앞에 있는 비트 2개가 밀려난다.
2. 밀려난 비트들은 버리고, 뒤에 빈 자리를 0으로 채워준다.
3. 결과 a는 12

<br>

#### 오른쪽 시프트 연산

**TIP.** 음수를 오른쪽 시프트 연산할 경우 비어 있는 자리를 0이 아닌 1로 채워준다.

``` cs
int a = 12;
a >> 1
```
1. 오른쪽으로 1비트 이동하기 때문에 뒤에 있는 비트 1개가 밀려난다.
2. 밀려난 비트들은 버리고, 앞에 빈 자리를 0으로 채워준다.
3. 결과는 a는 6

<br>

## 비트 논리 연산자
**논리곱 연산자 `&`**
같은 자리의 두 비트가 둘 다 1이면 1, 그렇지 않으면 0
``` cs
int a = 10;
int b = 6;

int result = 2;
```

<br>

**논리합 연산자 `|`**
같안 자리의 두 비트가 둘 다 0이면 0, 그렇지 않으면 1
``` cs
int a = 10;
int b = 6;

int result = 14;
```

<br>

**배타적 논리합 연산자 `^`**
같은 자리의 두 비트가 같은 0, 다르면 1
``` cs
int a = 10;
int b = 6;

int result = 12;
```

<br>

**보수 연산자**
0은 1로, 1은 0으로 반전
``` cs
int a = 10;
~a = -11;
```
**TIP. 보수 연산을  하면 부호가 바뀌게 되며 양수였으면 결과 값은 +1 (ex. 10의 보수는 -11) <br>음수였으면 결과 값은 -1 (ex. -10의 보수는 9)**

<br>

## 연산자 우선순위
**TIP. 연산자마다 우선순위가 정해져 있다.**<br>
**우선순위가 같을 경우 왼쪽의 연산자를 먼저 계산한다.**<br>
**괄호 안에 있는 연산자가 우선 계산된다.**<br>
**헷갈리면 괄호로 구분하는게 최고다.**<br>
|우선순위|종류|연산자|
|-|-|-|
|1|증가/감소 연산자|`++`, `--`|
|2|산술 연산자|`*`,`/`,`%`|
|3|산술 연산자|`+`,`-`|
|4|시프트 연산자|`<<`,`>>`|
|5|관계 연산자|`<`,`>`|
|6|관계 연산자|`==`,`!=`|
|7|비트 논리 연산자|왼쪽부터 순서대로 `&`, `^`, `\|`|
|8|논리 연산자|왼쪽부터 순서대로 `&&`, `||`|
|9|조건 연산자|`?:`|
|10|할당 연산자|`=`, `*=`, `/=`, `%=`, `+=`, `-=`, `<<=`, `>>=`, `&=`, `^=`, `\|=`|

<br>

**참고 자료**
[[Unity C#] #06 연산자](https://www.youtube.com/watch?v=Ci9k6ECcRp0)
